<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"> <title>ITA Baranov’s Walkthrough. Chapter 2 &#8211; Makar Baranov</title> <meta name="description" content="Insertion &amp; Merge sorts. Analyzing the Algorithm"> <meta name="keywords" content="Insertion Sort, Runtime Complexity, Merge Sort"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="avatar.png"> <meta name="twitter:title" content="ITA Baranov's Walkthrough. Chapter 2"> <meta name="twitter:description" content="Insertion &amp; Merge sorts. Analyzing the Algorithm"> <!-- Open Graph --> <meta property="og:locale" content="en_US"> <meta property="og:type" content="article"> <meta property="og:title" content="ITA Baranov's Walkthrough. Chapter 2"> <meta property="og:description" content="Insertion &amp; Merge sorts. Analyzing the Algorithm"> <meta property="og:url" content="https://login-m.github.io/Algorithms-&-Data-Structures-2/"> <meta property="og:site_name" content="Makar Baranov"> <meta property="og:image" content="https://login-m.github.io/images/avatar.png"> <link rel="canonical" href="https://login-m.github.io/Algorithms-&-Data-Structures-2/"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Feed --> <link type="application/atom+xml" rel="alternate" href="https://login-m.github.io/feed.xml" title="Makar Baranov" /> <!-- Favicons --> <link rel="shortcut icon" type="image/png" href="https://login-m.github.io/favicon.png" /> <link rel="shortcut icon" href="https://login-m.github.io/favicon.ico" /> <!-- CSS --> <link rel="stylesheet" type="text/css" href="https://login-m.github.io/assets/css/main.css"> <!-- Left Block Image for Posts --> <style type="text/css"> #posts.inner-post-page .block-left {background: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url(https://login-m.github.io/images/unsplash-gallery-image-3.jpg) no-repeat;background-size: cover;} </style> <!-- Left Block Images for Home and Pages --> <style type="text/css"> #posts .block-left {background: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url(https://login-m.github.io/images/unsplash-image-10.jpg) no-repeat;background-size: cover, cover;} .block-left {background: linear-gradient(rgba(44,45,51,0.9), rgba(44,45,51,0.9)), url(https://login-m.github.io/images/home.png) no-repeat;background-size: cover;} </style> </head> <body id="posts" class="inner-post-page"> <div class="block-left"> <div class="content"> <a href="https://login-m.github.io" class="logo"><img src="https://login-m.github.io/images/avatar.png"></a> <div class="post-title-section"> <div class="section-line">Posts <em>/</em></div> <h1 class="section-title">ITA Baranov’s Walkthrough. Chapter 2 </h1> <ul class="tags"> <li><a href="https://login-m.github.io/tags#Insertion Sort">Insertion Sort</a></li> <li><a href="https://login-m.github.io/tags#Runtime Complexity">Runtime Complexity</a></li> <li><a href="https://login-m.github.io/tags#Merge Sort">Merge Sort</a></li> </ul> <div class="section-line reverse"><a href="https://login-m.github.io/posts">Back to posts</a> <em>/</em></div> </div> </div> </div> <div class="block-right"> <div class="share-buttons"> <a href="https://twitter.com/intent/tweet?text=https://login-m.github.io/Algorithms-&-Data-Structures-2/" class="btn btn_twitter" title="Share on Twitter"><i class="fa fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a> <a href="https://www.facebook.com/sharer/sharer.php?u=https://login-m.github.io/Algorithms-&-Data-Structures-2/" class="btn btn_facebook" title="Share on Facebook"><i class="fa fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a> <a href="https://plus.google.com/share?url=https://login-m.github.io/Algorithms-&-Data-Structures-2/" class="btn btn_google-plus" title="Share on Google Plus"><i class="fa fa-fw fa-google-plus" aria-hidden="true"></i><span> Google+</span></a> </div> <a href="../posts.html" title="posts" class="posts-menu-icon"></a> <a title="projects" class="projects-menu-icon"> <span></span> </a> <div class="inner-post content"> <div class="date-highlight">19 Dec 2016</div> <p style="text-align: center;"><strong>Insertion Sort</strong></p> <p>Chapter 2 introduces <strong>insertion sort</strong>, an algorithm that solves the sorting problem mentioned in a previous chapter.</p> <dl style="text-align: left;"> <dt>Input</dt> <dd>A sequence of <strong>n</strong> numbers <strong>&lt;a<sub>1</sub>, a<sub>2</sub>, …, a<sub>n</sub>&gt;</strong></dd> <dt>Output</dt> <dd>A permutation <strong>&lt;b<sub>1</sub>, b<sub>2</sub>, …, b<sub>n</sub>&gt;</strong> of the input sequence such that <strong>b<sub>1</sub> ≤ b<sub>2</sub> ≤ … ≤ b<sub>n</sub></strong></dd> </dl><pre>
INSERTION-SORT(A)						cost 	times
for j = 2 to A.length						c<sub>1</sub>	n
	key = A[j]						c<sub>2</sub>	n-1
	// Insert A[j] into the sorted sequence A[1..j-1].	0	n-1
	i = j - 1						c<sub>4</sub>	n-1	
	while i &gt; 0 and A[i] &gt; key				c<sub>5</sub>	Σ(j=2 to n) t<sub>j</sub>
	  A[i+1] = A[i]						c<sub>6</sub>	Σ(j=2 to n) t<sub>j</sub> - 1
	  i = i - 1						c<sub>7</sub>	Σ(j=2 to n) t<sub>j</sub> - 1
	A[i+1] = key						c<sub>8</sub>	n-1
</pre><p style="text-align: left;">Basically, algorithm divides the sequence in two parts. The left part <strong>A[1…j-1]</strong> constitutes the currently sorted subarray and the right part is a subarray <strong>A[j+1…n]</strong> that corresponds to the numbers to be sorted. What you want to do is to pick an element (starting from 2), go down the array and try to find a good spot to fit the number in, at the same time copying the values one place over to have a free slot for insertion.</p> <p style="text-align: center;"><strong>Analyzing algorithms</strong></p> <dl> <dt>Running Time <strong>T(N)</strong></dt> <dd>The running time of the algorithm is the sum of running times for each statement executed; a statement that takes <strong>c<sub>i</sub></strong> steps to execute and executes <strong>n</strong> times will contribute <strong>c<sub>i</sub>n</strong> to the total running time.</dd> </dl> <p style="text-align: left;">T(N) = c<sub>1</sub>*n c<sub>2</sub>(n-1) +c<sub>4</sub>(n-1) +c<sub>5</sub>Σj +c<sub>6</sub>Σ(t<sub>j</sub>-1) +c<sub>7</sub>Σ(t<sub>j</sub>-1) +c<sub>8</sub>(n-1).</p> <p style="text-align: left;">Algorithm’s running time does depend on the input. For example, if the input array is sorted, we would have A[i] key when i has its initial value of j-1. Thus t<sub>j</sub> = 1 for j = 2, 3 … n and the T(N) would be:<br /> T(N) = c<sub>1</sub>n +c<sub>2</sub>(n-1) +c<sub>4</sub>(n-1) +c<sub>5</sub>(n-1) +c<sub>8</sub>(n-1) = (c<sub>1</sub>+..c<sub>8</sub>)n - (c<sub>2</sub>+c<sub>4</sub>+c<sub>5</sub>+c<sub>8</sub>) = <strong>Cn - c</strong><br /> This clearly looks like a <span style="color:red">linear</span> function of n.</p> <p style="text-align: left;">Another example, array is in reverse sorted order, then we must compare the entire left subarray which would make t<sub>j</sub> = j for j = 2, 3 … n. Consequently, T(N) would look like:<br /> T(N) = c<sub>1</sub>n +c<sub>2</sub>(n-1) +c<sub>4</sub>(n-1) +c<sub>5</sub>(n(n+1)/2-1) + c<sub>6</sub>(n(n-1)/2) + c<sub>7</sub>(n(n-1)/2) +c<sub>8</sub>(n-1) <br /> = <strong>Cn<sup>2</sup> + Cn - c</strong><br /> This clearly looks like a <span style="color:red">quadratic</span> function of n.</p> <p class="notice_info">Notice that Σ(j=2 to n)[j] = n(n+1)/2-1 and Σ(j=2 to n)[j-1] = n(n-1)/2</p> <p>When we try to analyze algorithms, we usually only care about finding the <strong>worst-case</strong> running times. Why?</p> <ol style="text-align: left;"> <li>It gives an upper bound on the running time for any input. Knowing it provides a guarantee that the algorithm will never take any longer.</li> <li>In some cases, worst case occurs fairly often (e.g. searching a database for non-existent information)</li> <li>The “average case” is often roughly as bad as the worst case. For example, imagine that half of the elements in A[1…j-1] are less than A[j] and half are greater. It would make t<sub>j</sub> = j/2 which would be the same quadratic formula but divided by a constant (2), not a huge difference.</li> </ol> <p style="text-align: left;">To denote the worst case we write the running time of <strong>Θ(n<sup>2</sup>)</strong> (pronounced “theta of n-squared”) which represents a rate of growth or order of growth. We can ignore the lower-order terms because they are relatively insignificant for large values of n. All we care about is the leading term of the formula (e.g., cn<sup>2</sup>).</p> <p style="text-align: center;"><strong>Algorithm Design &amp; Mergesort</strong></p> <p style="text-align: left;">Sometimes, we can come up with a different approach to tackle the same problem. So far we used an incremental approach: to sort the subarray A[1…j-1], we inserted a single element A[j] into its proper place, yielding the sorted subarray. A different way of doing things would be using <strong>divide-and-conquer</strong> method: break the problem into several subproblems that are similar to the original problem but smaller in size, solve the subproblems recursively, and finally combine these solutions to create a solution to the original problem. Mergesort algorithm would be a good example of this.</p> <p style="text-align: left;"><strong>Divide</strong>: Divide the n-element sequence to be sorted into two subsequences of n/2 elements each.<br /> <strong>Conquer</strong>: Sort the two subsequences recursively using merge sort. <br /> <strong>Combine</strong>: Merge the two sorted subsequences to produce a fully sorted sequence.</p> <p style="text-align: left;">The following <code>MERGE</code> function merges two sorted subarrays <strong>A[p..q]</strong> and <strong>A[q + 1..r]</strong> where p ≤ q ≤ r. It merges them to form a single sorted subarray that replaces the current subarray <strong>A[p..r]</strong>. Since we perform at most n steps, where each step is just a comparing of two elements from left and right subarrays, merging takes Θ(N) time.</p><pre>
MERGE(A,p,q,r)
n1 = q-p+1
n2 = r-q
let L[1..n1+1] and R[1..n2 +1] be new arrays
for i = 1 to n1
	L[i] = A[p+i-1]
for j=1 to n2
	R[j] = A[q+j]
L[n1+1] = inf
L[n2+1] = inf
i = 1
j = 1
for k = p to r
	if L[i] &lt;= R[j]
		A[k] = L[i]
		i = i + 1
	else A[k] = R[j]
		j = j + 1
</pre><ol style="text-align: left;"> <li>Compute the length of <strong>A[p..q]</strong> and <strong>A[q+1..r]</strong>.</li> <li>Create left and right of lengths <strong>n<sub>1</sub>+1</strong> and <strong>n<sub>2</sub>+1</strong>. Extra position holds the sentinel which would simplify our code.</li> <li>For loops copy the subarray <strong>A[p..q]</strong> into <strong>L[1..n<sub>1</sub>]</strong> and <strong>A[q+1..r]</strong> into <strong>R[1..n<sub>2</sub>]</strong>.</li> <li>Put the sentinels.</li> <li>Put the values in <strong>A</strong> in order.</li> </ol> <p style="text-align: left;">Now we can use merge procedure as a subroutine in the merge sort algorithm. The procedure sorts the elements in the subarray <strong>A[p..r]</strong>. If p ≥ r the subarray has at most one element and is therefore already sorted. Otherwise, the divide step simply computes an index <strong>q</strong> that partitions A[p..r] into two subarrays: A[p..q], containing <strong>ceil(n/2)</strong> elements and A[q+1..r], containing <strong>floor(n/2)</strong> elements.</p><pre>
MERGE-SORT(A,p,r)
if p &lt; r
	q = floor((p+r)/2)
	MERGE-SORT(A,p,q)
	MERGE-SORT(A,q+1,r)
	MERGE(A,p,q,r)
</pre><p style="text-align: left;">To sort an entire array, we make the initial call <code>MERGE-SORT(A,1,A.length)</code>. The algorithms goes all the way to the bottom, merges pairs of 1-item seqs to form sorted seqs of length 2, merges pairs of seqs of length 2 to form sorted seqs of length 4 and so on, until two sequences of length n/2 are merged to form the final sorted sequence of length n.</p> <p><img src="/images/mergesort.png" alt="image-center" class="align-center" /></p> <p style="text-align: center;"><strong>Runtime Complexity</strong></p> <p style="text-align: left;">T(n) is either going to be Θ(1) if n ≤ c or aT(n/b) + D(n) + C(n). <br /> In our case: <br /> 1) D(n) is Θ(1) operation (finding q) [Divide] <br /> 2) We recursively solve two subproblems, each of size n/2, which contributes to 2T(n/2) to the running time [Conquer] <br /> 3) We have seen that MERGE takes Θ(N) time on n-element subarray so C(N) = Θ(N) [Combine]<br /> Thus, we get T(n) = Θ(1) [if n ≤ c] or 2T*(n/2) + Θ(n) [if n &gt; 1]</p> <p>So what exactly is 2T*(n/2)? To find it out, let’s refer to a recursion tree to better understand the first term.</p> <dl> <dt>Recursion Tree</dt> <dd>A recursion tree is useful for visualizing what happens when a recurrence is iterated. It diagrams the tree of recursive calls and the amount of work done at each call.</dd> </dl> <p><img src="/images/mergesort_rt.jpg" alt="image-center" class="align-center" /></p> <p>First level takes cn time. <br /> Second level takes 2(cn/2) = cn. <br /> Third level takes 4(cn/4) = cn. <br /> To find out the total running time we need to sum up all the costs on each level. How do we know the number of levels?</p> <dl> <dt>Number of levels of the recursion tree</dt> <dd>The total number of levels of the recursion tree is <strong>lgn + 1</strong>, where n is the number of leaves, corresponding to the input size.</dd> </dl> <p style="text-align: left;">Then, our recursion tree has lgn + 1 levels, each costing cn, for a total of cn(lgn + 1) = cnlgn + cn. <br /> Substitute this in our previous T(n) equation and we get: <br /> T(n) = Θ(1) [if n ≤ c] or cnlgn + cn + Θ(n) = Θ(nlgn) [if n &gt; 1].<br /> This is a much better runtime complexity than the insertion sort we looked at earlier.</p> <br> <a href="https://twitter.com/intent/tweet?text=https://login-m.github.io/Algorithms-&-Data-Structures-2/" class="btn btn_twitter" title="Share on Twitter"><i class="fa fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a> <a href="https://www.facebook.com/sharer/sharer.php?u=https://login-m.github.io/Algorithms-&-Data-Structures-2/" class="btn btn_facebook" title="Share on Facebook"><i class="fa fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a> <a href="https://plus.google.com/share?url=https://login-m.github.io/Algorithms-&-Data-Structures-2/" class="btn btn_google-plus" title="Share on Google Plus"><i class="fa fa-fw fa-google-plus" aria-hidden="true"></i><span> Google+</span></a> <nav class="pagination"> <a href="https://login-m.github.io/Algorithms-&-Data-Structures-1/" class="pagination_pager" title="ITA Baranov’s Walkthrough. Chapter 1 ">previous</a> <a href="https://login-m.github.io/Algorithms-&-Data-Structures-3/" class="pagination_pager" title="ITA Baranov’s Walkthrough. Chapter 3 ">next</a> </nav> </div> </div> <!-- JS --> <script src="https://login-m.github.io/assets/js/main.min.js"></script> <div class="overlay"> <ul class="projects-menu"> <li style="background:url(https://login-m.github.io//images/home-image.png) center center no-repeat;"> <a href="https://github.com/login-m/login-m.github.io" target="_blank" rel="nofollow external"> <span> My Blog </span> </a> </li> <li style="background:url(https://login-m.github.io//images/arcade-jet.png) center center no-repeat;"> <a href="https://github.com/login-m/game/" target="_blank" rel="nofollow external"> <span> Arcade Jet 2000 </span> </a> </li> <li style="background:url(https://login-m.github.io//images/walkthrough.png) center center no-repeat;"> <a href="https://login-m.github.io/Walkthrough/" class="inactive" target="_blank" rel="nofollow external"> <span> ITA Baranov's Walkthrough <br><em>in progress</em> </span> </a> </li> </ul> </div> </body> </html>
